do local a=package.searchers or package.loaders;local b=a[2]a[2]=function(c)local d={["tar.lib"]=function()local e=true;local f="000755 \0"local g=string.rep("\0",32)local h=g;local i=string.rep("\0",100)local j="000000 \0"local k=j;local l=j;local m=k;local n="0"local o="5"local p="00"local q="ustar\0"local r=string.rep(" ",8)local s=string.rep("\0",512)local function u(string,v,w)w=w or"0"if#string>=v then return string end;return string.rep(w,v-#string)..string end;local function x(string,v,w)w=w or"0"if#string>=v then return string end;return string..string.rep(w,v-#string)end;local function y(z)return string.format("%o",z)end;local function A(B)local C=0;for w in string.gmatch(B,".")do C=C+string.byte(w)end;return string.format("%06s",y(C)).."\0 "end;local function D(E,c)local F=E.."/"..c;assert(fs.exists(F),"The file path "..F.." does not exist")local G=fs.isDir(F)and o or n;local H=u(y(fs.getSize(F)),11,0).." "local I=u(y(os.date("%s")),11).." "local name,J;if#c>100 then J=string.sub(c,1,155)name=x(string.sub(c,156,255),100,"\0")else name=x(c,100,"\0")J=string.rep("\0",155)end;local K=name..f..l..m..H..I;local L=G..i..q..p..g..h..j..k..J;local C=A(K..r..L)return x(K..C..L,512,"\0")end;local function M(B,N)for O=1,#B do N.write(string.byte(B,O))end end;local function P(E,c,N)local F=E.."/"..c;assert(fs.exists(F))local B=D(E,c)M(B,N)local H=fs.getSize(F)local Q=0;if not fs.isDir(F)then Q=512-H%512 end;local R=fs.open(F,"rb")for S=1,H do N.write(R.read())end;for S=1,Q do N.write(0)end end;local function T(N)for S=1,1024 do N.write(0)end;N.close()end;local function U(V,W)for S,X in ipairs(V)do if X==W then return true end end;return false end;local function Y(E,Z,_,a0,a1)local a2=E.."/"..Z;print(a2)if U(_,a2)then return end;if not fs.isDir(a2)then P(E,Z,a0)return else if#fs.list(a2)==0 then P(E,Z,a0)end end;for S,a3 in ipairs(fs.list(a2))do if e and string.sub(a3,1,1)~="."or not e then local a4=Z.."/"..a3;local a5=E.."/"..a4;if fs.isDir(a5)then Y(E,a4,_,a0,a1)elseif a5~=a1 then if not U(_,a5)then P(E,a4,a0)end end end end end;local function a6(c,a7,_,a0)assert(c,"No path was provided")if a7 then assert(string.sub(a7,-4)==".tar","Output file path must end with .tar!")end;local E,a8=string.match(c,"(.-)/([^/]+)$")E=E or""a8=a8 or c;a7=a7 or"/"..E.."/"..a8 ..".tar"a0=a0 or fs.open(a7,"wb")Y(E,a8,_,a0,a7)T(a0)end;local function a9(B,aa,ab)local ac=B:sub(aa,ab):gsub("\0","")ac=ac:gsub("^%s+","")ac=ac:gsub("%s+$","")return ac end;local function ad(B)local name=a9(B,1,100)local J=a9(B,345,500)local H=tonumber(a9(B,124,136),8)local type=tonumber(a9(B,156,157))return name,J,H,type end;local function ae(af,H,R)local a0=fs.open(af,"wb")for S=1,H do a0.write(R.read())end;local Q=512-H%512;if Q~=512 then for S=1,Q do R.read()end end;a0.close()end;local function ag(c,af)af=af or shell.dir()assert(fs.exists(c))assert(string.sub(c,-4)==".tar","File is not a tar file")assert(fs.getSize(c)%512==0,"File size is not a multiple of 512. Invalid tar.")local R=fs.open(c,"rb")for S=1,fs.getSize(c)/512-1 do local B=R.read(512)if B==nil then return end;if B~=s then local name,J,H,type=ad(B)local ah=af.."/"..(J and J..name or name)if type==5 then fs.makeDir(ah)else if not fs.exists(ah)then ae(ah,H,R)else for O=1,512 do R.read()end end end end end end;local ai={tar=a6,untar=ag}return ai end,["base64.lib"]=function()local aj="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"local ak={}local al={}for O=1,#aj do local w=aj:sub(O,O)ak[O]=w;al[w]=O-1 end;local am,an,ao=bit.blshift,bit.blogic_rshift,bit.band;local function ap(aq,ar,as)assert(aq,"At least one input byte required")local at=not ar and 1 or not as and 2 or 3;ar=ar or 0;as=as or 0;local au=am(aq,16)+am(ar,8)+as;local a7=""for O=3,3-at,-1 do a7=a7 ..ak[1+tonumber(ao(an(au,O*6),0x3f))]end;a7=a7 ..string.rep("=",3-at)return a7 end;local function av(aw)assert(#aw==4,"Chars must be of length 4")local Q=#aw:gsub("[^=]","")local ax=aw:gsub("=","A")local ay=0;local a7={}for O=1,4 do ay=ay+am(al[ax:sub(O,O)],24-O*6)end;for O=1,3 do a7[O]=ao(an(ay,24-O*8),0xff)end;return a7,Q end;local function P(c)assert(fs.exists(c),'File does not exist')local R=fs.open(c,"rb")local a7=""for S=1,fs.getSize(c),3 do local aq,ar,as=R.read(),R.read(),R.read()a7=a7 ..ap(aq,ar,as)end;return a7 end;local function az(aA,af)assert(#aA%4==0,"Coded string should be a multiple of 4")local a0=fs.open(af,"wb")for O=1,#aA,4 do local aB,Q=av(aA:sub(O,O+3))for aC=1,3-Q do a0.write(aB[aC])end end;a0.close()end;local aD={encodeFile=P,decodeFile=az}return aD end,["functions.add"]=function()local aE=require"functions.install.downloadFile"local aF=require"functions.delete"require"functions.json"local function aG(aH)local name=aH[2]local aI=aH[3]if not name then return"A name must be provided in order to add a package"end;local aJ=shell.dir()local aK=fs.combine(aJ,"package.json")local aL={}if fs.exists(aK)then aL=decodeFromFile(aK)end;if aL and aL.dependencies[name]then aF({0,name})end;local aM=aE(name,aI)if not aL.dependencies then aL.dependencies={}end;aL.dependencies[aH[2]]="^"..aM;local aN=fs.open(aK,"w")aN.write(encodePretty(aL))end;return aG end,["functions.delete"]=function()require"functions.json"require"functions.delete.deletePackage"local aO=require"functions.delete.deletePackage"local function aF(aH)local aJ=shell.dir()local aP=aH[2]if not aP then return end;local aQ=fs.combine(aJ,"package.json")if not aQ then return"No package.json found."end;local aL=decodeFromFile(aQ)if not aL.dependencies then return"No dependencies to delete"end;if not aL.dependencies[aP]then return string.format("%s not found. Perhaps you made a typo?",aP)end;aL.dependencies[aP]=nil;local aR=fs.combine(aJ,"package-lock.json")local aS={}if fs.exists(aQ)then aS=decodeFromFile(aR)end;local aT=aJ.."/luam_modules/"..aP;if not fs.exists(aT)then return string.format("%s not found",aT)end;aO(aP,aT,aS)local aN=fs.open(aQ,"w")aN.write(encodePretty(aL))aN.close()local aU=fs.open(aR,"w")aU.write(encodePretty(aS))aU.close()end;return aF end,["functions.init"]=function()require"functions.json"local function aV(aH)local aJ=shell.dir()if aH[2]then aJ=aJ.."/"..aH[2]end;local aQ=fs.combine(aJ,"package.json")if fs.exists(aQ)then print("Package has already been initialized. Write over existing information? (y/n)")local aW=io.read()if aW~="y"then return"Project initalization aborted"end end;local a0=fs.open(aQ,"w")local aX={name=aH[2]or"",version="0.1.0",dependencies={}}a0.write(encodePretty(aX))local aY=fs.open(fs.combine(aJ,".luamignore"),"w")aY.write("luam_modules\n")aY.write("package-lock.json")return string.format("Package %s has been initialized",name)end;return aV end,["functions.json"]=function()local aZ={["\n"]="\\n",["\r"]="\\r",["\t"]="\\t",["\b"]="\\b",["\f"]="\\f",["\""]="\\\"",["\\"]="\\\\"}local function a_(t)local b0=0;for b1,b2 in pairs(t)do if type(b1)~="number"then return false elseif b1>b0 then b0=b1 end end;return b0==#t end;local b3={['\n']=true,['\r']=true,['\t']=true,[' ']=true,[',']=true,[':']=true}function removeWhite(b4)while b3[b4:sub(1,1)]do b4=b4:sub(2)end;return b4 end;local function b5(b6,b7,b8,b9)local b4=""local function ba(bb)b4=b4 ..("\t"):rep(b8)..bb end;local function bc(b6,bd,be,bf,bg)b4=b4 ..bd;if b7 then b4=b4 .."\n"b8=b8+1 end;for b1,b2 in bf(b6)do ba("")bg(b1,b2)b4=b4 ..","if b7 then b4=b4 .."\n"end end;if b7 then b8=b8-1 end;if b4:sub(-2)==",\n"then b4=b4:sub(1,-3).."\n"elseif b4:sub(-1)==","then b4=b4:sub(1,-2)end;ba(be)end;if type(b6)=="table"then b9[b6]=true;if a_(b6)then bc(b6,"[","]",ipairs,function(b1,b2)b4=b4 ..b5(b2,b7,b8,b9)end)else bc(b6,"{","}",pairs,function(b1,b2)assert(type(b1)=="string","JSON object keys must be strings",2)b4=b4 ..b5(b1,b7,b8,b9)b4=b4 ..(b7 and": "or":")..b5(b2,b7,b8,b9)end)end elseif type(b6)=="string"then b4='"'..b6:gsub("[%c\"\\]",aZ)..'"'elseif type(b6)=="number"or type(b6)=="boolean"then b4=tostring(b6)else error("JSON only supports arrays, objects, numbers, booleans, and strings",2)end;return b4 end;function encode(b6)return b5(b6,false,0,{})end;function encodePretty(b6)return b5(b6,true,0,{})end;local bh={}for b1,b2 in pairs(aZ)do bh[b2]=b1 end;function parseBoolean(b4)if b4:sub(1,4)=="true"then return true,removeWhite(b4:sub(5))else return false,removeWhite(b4:sub(6))end end;function parseNull(b4)return nil,removeWhite(b4:sub(5))end;local bi={['e']=true,['E']=true,['+']=true,['-']=true,['.']=true}function parseNumber(b4)local O=1;while bi[b4:sub(O,O)]or tonumber(b4:sub(O,O))do O=O+1 end;local b6=tonumber(b4:sub(1,O-1))b4=removeWhite(b4:sub(O))return b6,b4 end;function parseString(b4)b4=b4:sub(2)local bb=""while b4:sub(1,1)~="\""do local bj=b4:sub(1,1)b4=b4:sub(2)assert(bj~="\n","Unclosed string")if bj=="\\"then local bk=b4:sub(1,1)b4=b4:sub(2)bj=assert(bh[bj..bk],"Invalid escape character")end;bb=bb..bj end;return bb,removeWhite(b4:sub(2))end;function parseArray(b4)b4=removeWhite(b4:sub(2))local b6={}local O=1;while b4:sub(1,1)~="]"do local b2=nil;b2,b4=parseValue(b4)b6[O]=b2;O=O+1;b4=removeWhite(b4)end;b4=removeWhite(b4:sub(2))return b6,b4 end;function parseObject(b4)b4=removeWhite(b4:sub(2))local b6={}while b4:sub(1,1)~="}"do local b1,b2=nil,nil;b1,b2,b4=parseMember(b4)b6[b1]=b2;b4=removeWhite(b4)end;b4=removeWhite(b4:sub(2))return b6,b4 end;function parseMember(b4)local b1=nil;b1,b4=parseValue(b4)local b6=nil;b6,b4=parseValue(b4)return b1,b6,b4 end;function parseValue(b4)local bl=b4:sub(1,1)if bl=="{"then return parseObject(b4)elseif bl=="["then return parseArray(b4)elseif tonumber(bl)~=nil or bi[bl]then return parseNumber(b4)elseif b4:sub(1,4)=="true"or b4:sub(1,5)=="false"then return parseBoolean(b4)elseif bl=="\""then return parseString(b4)elseif b4:sub(1,4)=="null"then return parseNull(b4)end;return nil end;function decode(b4)b4=removeWhite(b4)t=parseValue(b4)return t end;function decodeFromFile(c)local bm=assert(fs.open(c,"r"))local bn=decode(bm.readAll())bm.close()return bn end end,["functions.login"]=function()local function bo(aH)print("API Token: ")local bp=io.read()local bq=fs.open("luam.key","w")bq.write(bp)bq.close()return"API token now in use"end;return bo end,["functions.post"]=function()local P=require("functions.post.encodeFile")require("functions.json")local br="https://api.luam.dev/packages"local function bs(aL)local bt={"name","version","dependencies"}for S,bu in ipairs(bt)do if not aL[bu]then error(string.format('Required field "%s" missing from package.json',bu))end end end;local function bv()local aJ=shell.dir()local aQ=fs.combine(aJ,"package.json")if not fs.exists('luam.key')then return'No api token found. Run luam login and provide a valid api token.'end;local bw=fs.open("luam.key","r").readAll()if not fs.exists(aQ)then return'"package.json" not found. Run "luam init" to initialize package.'end;local aL=decodeFromFile(aQ)bs(aL)local bx=fs.combine(aJ,".luamignore")local by={}if fs.exists(bx)then local bz=fs.open(bx,"r")local bA="temp"while bA do bA=bz.readLine()if not bA then break end;table.insert(by,aJ.."/"..bA)end end;local bB=P(aJ,by)local bC={name=aL.name,version=aL.version,dependencies=aL.dependencies,payload=bB}local aW,bD,bE=http.post(br,encode(bC),{Authorization=bw})if not aW then if not bE then return"The request timed out. Either luam is down or it is blocked on your network"end;return string.format("%s: %s",bD,decode(bE.readAll()).message or"No message provided")end;return string.format("%s v%s was posted successfully!",aL.name,aL.version)end;return bv end,["functions.delete.deletePackage"]=function()local function bF(bG)local bH=bG:match(".*()/")return bH and bG:sub(1,bH-1)or bG end;local function bI(bJ,bK,bL,aS)bL=bL.."/luam_modules/"..bJ;while bL~=bK do if aS[bL]then return false end;for S=1,3 do bL=bF(bL)end;bL=bL.."/"..bJ end;return true end;local function bM(c,bN,aS)c=c.."/luam_modules/"..bN;while#c>0 do local ax=aS[c]if ax then return c end;for O=1,3 do local bO=c;c=bF(c)if bO==c then return end end;c=c.."/"..bN end end;local function bP(bQ,bR)for b1,S in pairs(bQ)do if b1==bR then return true end end;return false end;local function aO(name,c,aS)for aK,bS in pairs(aS)do if bP(bS.dependencies,name)then print(bS.name)if bI(name,c,aK,aS)then return end end end;local ax=aS[c]local bT=ax.dependencies;fs.delete(c)aS[c]=nil;for bU in pairs(aS)do if bU:sub(1,#c)==c then aS[bU]=nil end end;for bV in pairs(bT)do local bW=bM(c,bV,aS)if bW then aO(bV,bW,aS)end end end;return aO end,["functions.install.downloadFile"]=function()require"functions.json"local a6=require("tar.lib")local bX=require("base64.lib")local bY="https://api.luam.dev/packages/install"local bZ=require(".tableutils.lib")local function b_(E,name,c0)local c1=E.."/"..name..".tar"bX.decodeFile(c0,c1)a6.untar(c1,E)fs.delete(c1)end;local function U(table,W)for S,X in ipairs(table)do if X==W then return true end end;return false end;local function c2(bQ)local c3={}for S,W in ipairs(bQ)do table.insert(c3,W)end;return c3 end;local function c4(c5,c6,O,name)for aC=1,O do c5=c5 .."/luam_modules/"..c6[aC]end;if name then c5=c5 .."/luam_modules/"..name end;return c5 end;local function bF(bG)local bH=bG:match(".*()/")return bH and bG:sub(1,bH-1)or bG end;local function bM(c,bN,c7,aS)c=c.."/luam_modules/"..bN;while#c>0 do local ax=aS[c]if ax and ax.name==bN and ax.version==c7 then return c end;for O=1,3 do local bO=c;c=bF(c)if bO==c then return false end end;c=c.."/"..bN end end;local function c8(bS,c9,aS)local ca=""for c,ax in pairs(aS)do if ax.name==bS.name and ax.version==bS.version then ca=c end end;fs.copy(ca,c9)return ca end;local function aG(c5,cb,aS,cc,cd)local ce={}local cf=cb[cc][cd]cf.name=cc;cf.version=cd;cf.options={}table.insert(ce,cf)for S,W in ipairs(ce)do local name=W.name;local aI=W.version;local c6=W.options;local cg=c2(c6)table.insert(cg,name)for O=0,#c6 do local c9=c4(c5,c6,O,name)if aS[c9]and aS[c9].version==aI then break end;if not aS[c9]then if W.payload then b_(bF(c9),name,W.payload)aS[c9]={name=W.name,version=W.version,dependencies=W.dependencies}for bV,ch in pairs(W.providedDependencyVersions)do local ci=nil;if cb[bV]and cb[bV][ch]then ci=cb[bV][ch]ci.name=bV;ci.version=ch else ci={name=bV,version=ch}end;ci.options=cg;table.insert(ce,ci)end else local cj=""if aI then cj=c8(W,c9,aS)else local ck=bM(W.copied_from_path,name)cj=c8(ck,c9,aS)end;local cl=aS[cj]aS[c9]=cl;for bV,S in pairs(cl.dependencies)do table.insert(ce,{options=cg,name=bV,copied_from_path=cj})end end;break end end end end;local function aE(name,aI)local aJ=shell.dir()local aR=fs.combine(aJ,"package-lock.json")local aS={}if fs.exists(aR)then aS=decodeFromFile(aR)or{}end;local cm={}for S,package in pairs(aS)do local name=package.name;local aI=package.version;if not cm[name]then cm[name]={}end;if not U(cm[name],aI)then table.insert(cm[name],aI)end end;local cn=encode(cm)if cn=="[]"then cn="{}"end;local co={["X-PackageName"]=name,["X-PackageVersion"]=aI,["Content-Type"]="application/json"}local aW,cp,cq=http.post(bY,cn,co)if not aW then error(string.format("%s: %s",cp,cq and cq.readAll()))end;local cr=decode(aW.readAll())local aM=aI;for b1 in pairs(cr[name])do aM=b1 end;aG(aJ,cr,aS,name,aM)local aU=fs.open(aR,"w")aU.write(encodePretty(aS))aU.close()local cs=0;for aI,S in pairs(cr)do for package,S in pairs(cr[aI])do cs=cs+1 end end;print(string.format("%s package%s installed",cs,cs>1 and"s"or""))return aM end;return aE end,["functions.post.encodeFile"]=function()local ai=require("tar.lib")local aD=require("base64.lib")local function P(c,ct)assert(fs.exists(c),"File does not exist!")local cu="temp-"..math.floor(1000*math.random())..".tar"ai.tar(c,cu,ct)local cv=aD.encodeFile(cu)fs.delete(cu)return cv end;return P end}if d[c]then return d[c]else return b(c)end end end;local aH={...}local aV=require"functions.init"local bv=require"functions.post"local cw=require"functions.add"local bo=require"functions.login"local aF=require"functions.delete"local cx={init=aV,post=bv,add=cw,a=cw,delete=aF,d=aF,login=bo}local aa=os.clock()local cy,aW=pcall(function()if not aH[1]then error("At least one argument expected.")end;if not cx[aH[1]]then error(string.format("%s is not a valid command",aH[1]))end;local aW=cx[aH[1]](aH)return aW end)if not cy then print("Error!")end;if aW then print(aW)end;print(string.format("Finished in %0.3f seconds",os.clock()-aa))
