do local a=package.searchers or package.loaders;local b=a[2]a[2]=function(c)local d={["base64.lib"]=function()local e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"local f={}local g={}for h=1,#e do local i=e:sub(h,h)f[h]=i;g[i]=h-1 end;local j,k,l=bit.blshift,bit.blogic_rshift,bit.band;local function m(n,o,p)assert(n,"At least one input byte required")local q=not o and 1 or not p and 2 or 3;o=o or 0;p=p or 0;local r=j(n,16)+j(o,8)+p;local s=""for h=3,3-q,-1 do s=s..f[1+tonumber(l(k(r,h*6),0x3f))]end;s=s..string.rep("=",3-q)return s end;local function u(v)assert(#v==4,"Chars must be of length 4")local w=#v:gsub("[^=]","")local x=v:gsub("=","A")local y=0;local s={}for h=1,4 do y=y+j(g[x:sub(h,h)],24-h*6)end;for h=1,3 do s[h]=l(k(y,24-h*8),0xff)end;return s,w end;local function z(c)assert(fs.exists(c),'File does not exist')local A=fs.open(c,"rb")local s=""for B=1,fs.getSize(c),3 do local n,o,p=A.read(),A.read(),A.read()s=s..m(n,o,p)end;return s end;local function C(D,E)assert(#D%4==0,"Coded string should be a multiple of 4")local F=fs.open(E,"wb")for h=1,#D,4 do local G,w=u(D:sub(h,h+3))for H=1,3-w do F.write(G[H])end end;F.close()end;local I={encodeFile=z,decodeFile=C}return I end,["functions.add"]=function()local J=require"functions.install.downloadFile"local K=require"functions.delete"require"functions.json"local function L(M)local N=M[2]local O=M[3]if not N then return"A name must be provided in order to add a package"end;local P=shell.dir()local Q=fs.combine(P,"package.json")local R={}if fs.exists(Q)then R=decodeFromFile(Q)end;if R and R.dependencies and R.dependencies[N]then K({0,N})end;local S=J(N,O)if not R.dependencies then R.dependencies={}end;R.dependencies[M[2]]="^"..S;local T=fs.open(Q,"w")T.write(encodePretty(R))end;return L end,["functions.versions"]=function()require"functions.json"local function U(O,V)local W,X,Y=O:match("(%d+)%.(%d+)%.(%d+)")W,X,Y=tonumber(W),tonumber(X),tonumber(Y)if V=="major"then return string.format("%d.0.0",W+1)elseif V=="minor"then return string.format("%d.%d.0",W,X+1)elseif V=="patch"then return string.format("%d.%d.%d",W,X,Y+1)else error("Invalid increment type: "..V)end end;local function Z(V)local P=shell.dir()local _=fs.combine(P,"package.json")if not fs.exists(_)then return"No package.json found!"end;local R=decodeFromFile(_)if not R["version"]then return"Must initialize package before incrementing version. Run luam init"end;local a0=U(R["version"],V or"patch")print(string.format("Updated to %s",a0))R["version"]=a0;local a1=fs.open(_,"w")a1.write(encodePretty(R))a1.close()return a0 end;local function a2()local P=shell.dir()local _=fs.combine(P,"package.json")if not fs.exists(_)then return"No package.json found!"end;local R=decodeFromFile(_)if not R["version"]then return"Must initialize package before incrementing version. Run luam init"end;print(string.format("Current package version: %s",R.version))end;return{list_version=a2,increment_version=Z}end,["functions.init"]=function()require"functions.json"local function a3(M)local P=shell.dir()if M[2]then P=P.."/"..M[2]end;local _=fs.combine(P,"package.json")local R={}if fs.exists(_)then R=decodeFromFile(_)end;if R["name"]then print("Package has already been initialized")end;local N=M[2]or P:match("([^/]+)$")local F=fs.open(_,"w")R["name"]=N;R["version"]="0.1.0"R["dependencies"]=R["dependencies"]or{}F.write(encodePretty(R))local a4=fs.open(fs.combine(P,".luamignore"),"w")a4.write("luam_modules\n")a4.write("package-lock.json")return string.format("Package %s has been initialized",N)end;return a3 end,["functions.login"]=function()local function a5(M)local a6=fs.open("luam.key","w")a6.write(M[2])a6.close()return"API token now in use"end;return a5 end,["functions.install.downloadFile"]=function()require"functions.json"local a7=require("tar.lib")local a8=require("base64.lib")local a9="https://api.luam.dev/packages/install"local function aa(ab,N,ac)local ad=ab.."/"..N..".tar"a8.decodeFile(ac,ad)a7.untar(ad,ab)fs.delete(ad)end;local function ae(table,af)for B,ag in ipairs(table)do if ag==af then return true end end;return false end;local function ah(ai)local aj={}for B,af in ipairs(ai)do table.insert(aj,af)end;return aj end;local function ak(al,am,h,N)for H=1,h do al=al.."/luam_modules/"..am[H]end;if N then al=al.."/luam_modules/"..N end;return al end;local function an(ao)local ap=ao:match(".*()/")return ap and ao:sub(1,ap-1)or ao end;local function aq(c,ar,as,at)c=c.."/luam_modules/"..ar;while#c>0 do local x=at[c]if x and x.name==ar and x.version==as then return c end;for h=1,3 do local au=c;c=an(c)if au==c then return false end end;c=c.."/"..ar end end;local function av(aw,ax,at)local ay=""for c,x in pairs(at)do if x.name==aw.name and x.version==aw.version then ay=c end end;fs.copy(ay,ax)return ay end;local function L(al,az,at,aA,aB)local aC={}local aD=az[aA][aB]aD.name=aA;aD.version=aB;aD.options={}table.insert(aC,aD)for B,af in ipairs(aC)do local N=af.name;local O=af.version;local am=af.options;local aE=ah(am)table.insert(aE,N)for h=0,#am do local ax=ak(al,am,h,N)if at[ax]and at[ax].version==O then break end;if not at[ax]then if af.payload then aa(an(ax),N,af.payload)at[ax]={name=af.name,version=af.version,dependencies=af.dependencies}for aF,aG in pairs(af.providedDependencyVersions)do local aH=nil;if az[aF]and az[aF][aG]then aH=az[aF][aG]aH.name=aF;aH.version=aG else aH={name=aF,version=aG}end;aH.options=aE;table.insert(aC,aH)end else local aI=""if O then aI=av(af,ax,at)else local aJ=aq(af.copied_from_path,N)aI=av(aJ,ax,at)end;local aK=at[aI]at[ax]=aK;for aF,B in pairs(aK.dependencies)do table.insert(aC,{options=aE,name=aF,copied_from_path=aI})end end;break end end end end;local function J(N,O)local P=shell.dir()local aL=fs.combine(P,"package-lock.json")local at={}if fs.exists(aL)then at=decodeFromFile(aL)or{}end;local aM={}for B,package in pairs(at)do local N=package.name;local O=package.version;if not aM[N]then aM[N]={}end;if not ae(aM[N],O)then table.insert(aM[N],O)end end;local aN=encode(aM)if aN=="[]"then aN="{}"end;local aO={["X-PackageName"]=N,["X-PackageVersion"]=O,["Content-Type"]="application/json"}local aP,aQ,aR=http.post(a9,aN,aO)if not aP then error(string.format("%s: %s",aQ,aR and aR.readAll()))end;local aS=decode(aP.readAll())local S=O;for aT in pairs(aS[N])do S=aT end;L(P,aS,at,N,S)local aU=fs.open(aL,"w")aU.write(encodePretty(at))aU.close()local aV=0;for O,B in pairs(aS)do for package,B in pairs(aS[O])do aV=aV+1 end end;print(string.format("%s package%s installed",aV,aV>1 and"s"or""))return S end;return J end,["functions.post.encodeFile"]=function()local aW=require("tar.lib")local I=require("base64.lib")local function z(c,aX)assert(fs.exists(c),"File does not exist!")local aY="temp-"..math.floor(1000*math.random())..".tar"aW.tar(c,aY,aX)local aZ=I.encodeFile(aY)fs.delete(aY)return aZ end;return z end,["functions.json"]=function()local a_={["\n"]="\\n",["\r"]="\\r",["\t"]="\\t",["\b"]="\\b",["\f"]="\\f",["\""]="\\\"",["\\"]="\\\\"}local function b0(t)local b1=0;for aT,b2 in pairs(t)do if type(aT)~="number"then return false elseif aT>b1 then b1=aT end end;return b1==#t end;local b3={['\n']=true,['\r']=true,['\t']=true,[' ']=true,[',']=true,[':']=true}function removeWhite(b4)while b3[b4:sub(1,1)]do b4=b4:sub(2)end;return b4 end;local function b5(b6,b7,b8,b9)local b4=""local function ba(bb)b4=b4 ..("\t"):rep(b8)..bb end;local function bc(b6,bd,be,bf,bg)b4=b4 ..bd;if b7 then b4=b4 .."\n"b8=b8+1 end;for aT,b2 in bf(b6)do ba("")bg(aT,b2)b4=b4 ..","if b7 then b4=b4 .."\n"end end;if b7 then b8=b8-1 end;if b4:sub(-2)==",\n"then b4=b4:sub(1,-3).."\n"elseif b4:sub(-1)==","then b4=b4:sub(1,-2)end;ba(be)end;if type(b6)=="table"then b9[b6]=true;if b0(b6)then bc(b6,"[","]",ipairs,function(aT,b2)b4=b4 ..b5(b2,b7,b8,b9)end)else bc(b6,"{","}",pairs,function(aT,b2)assert(type(aT)=="string","JSON object keys must be strings",2)b4=b4 ..b5(aT,b7,b8,b9)b4=b4 ..(b7 and": "or":")..b5(b2,b7,b8,b9)end)end elseif type(b6)=="string"then b4='"'..b6:gsub("[%c\"\\]",a_)..'"'elseif type(b6)=="number"or type(b6)=="boolean"then b4=tostring(b6)else error("JSON only supports arrays, objects, numbers, booleans, and strings",2)end;return b4 end;function encode(b6)return b5(b6,false,0,{})end;function encodePretty(b6)return b5(b6,true,0,{})end;local bh={}for aT,b2 in pairs(a_)do bh[b2]=aT end;function parseBoolean(b4)if b4:sub(1,4)=="true"then return true,removeWhite(b4:sub(5))else return false,removeWhite(b4:sub(6))end end;function parseNull(b4)return nil,removeWhite(b4:sub(5))end;local bi={['e']=true,['E']=true,['+']=true,['-']=true,['.']=true}function parseNumber(b4)local h=1;while bi[b4:sub(h,h)]or tonumber(b4:sub(h,h))do h=h+1 end;local b6=tonumber(b4:sub(1,h-1))b4=removeWhite(b4:sub(h))return b6,b4 end;function parseString(b4)b4=b4:sub(2)local bb=""while b4:sub(1,1)~="\""do local bj=b4:sub(1,1)b4=b4:sub(2)assert(bj~="\n","Unclosed string")if bj=="\\"then local bk=b4:sub(1,1)b4=b4:sub(2)bj=assert(bh[bj..bk],"Invalid escape character")end;bb=bb..bj end;return bb,removeWhite(b4:sub(2))end;function parseArray(b4)b4=removeWhite(b4:sub(2))local b6={}local h=1;while b4:sub(1,1)~="]"do local b2=nil;b2,b4=parseValue(b4)b6[h]=b2;h=h+1;b4=removeWhite(b4)end;b4=removeWhite(b4:sub(2))return b6,b4 end;function parseObject(b4)b4=removeWhite(b4:sub(2))local b6={}while b4:sub(1,1)~="}"do local aT,b2=nil,nil;aT,b2,b4=parseMember(b4)b6[aT]=b2;b4=removeWhite(b4)end;b4=removeWhite(b4:sub(2))return b6,b4 end;function parseMember(b4)local aT=nil;aT,b4=parseValue(b4)local b6=nil;b6,b4=parseValue(b4)return aT,b6,b4 end;function parseValue(b4)local bl=b4:sub(1,1)if bl=="{"then return parseObject(b4)elseif bl=="["then return parseArray(b4)elseif tonumber(bl)~=nil or bi[bl]then return parseNumber(b4)elseif b4:sub(1,4)=="true"or b4:sub(1,5)=="false"then return parseBoolean(b4)elseif bl=="\""then return parseString(b4)elseif b4:sub(1,4)=="null"then return parseNull(b4)end;return nil end;function decode(b4)b4=removeWhite(b4)t=parseValue(b4)return t end;function decodeFromFile(c)local bm=assert(fs.open(c,"r"))local bn=decode(bm.readAll())bm.close()return bn end end,["functions.delete.deletePackage"]=function()local function an(ao)local ap=ao:match(".*()/")return ap and ao:sub(1,ap-1)or ao end;local function bo(bp,bq,br,at)br=br.."/luam_modules/"..bp;while br~=bq do if at[br]then return false end;for B=1,3 do br=an(br)end;br=br.."/"..bp end;return true end;local function aq(c,ar,at)c=c.."/luam_modules/"..ar;while#c>0 do local x=at[c]if x then return c end;for h=1,3 do local au=c;c=an(c)if au==c then return end end;c=c.."/"..ar end end;local function bs(ai,bt)for aT,B in pairs(ai)do if aT==bt then return true end end;return false end;local function bu(N,c,at)for Q,aw in pairs(at)do if bs(aw.dependencies,N)then print(aw.name)if bo(N,c,Q,at)then return end end end;local x=at[c]local bv=x.dependencies;fs.delete(c)at[c]=nil;for bw in pairs(at)do if bw:sub(1,#c)==c then at[bw]=nil end end;for aF in pairs(bv)do local bx=aq(c,aF,at)if bx then bu(aF,bx,at)end end end;return bu end,["functions.post"]=function()local z=require("functions.post.encodeFile")local Z=require("functions.versions")require("functions.json")local by="https://api.luam.dev/packages"local function bz(R)local bA={"name","version","dependencies"}for B,bB in ipairs(bA)do if not R[bB]then error(string.format('Required field "%s" missing from package.json',bB))end end;local bC=fs.open(string.format(".luamversioncache/%s",R.name),"r")if bC then local O=bC.readAll()if O==R["version"]then local a0=Z("patch")R["version"]=a0 end end end;local function bD()local P=shell.dir()local _=fs.combine(P,"package.json")if not fs.exists('luam.key')then return'No api token found. Run luam login and provide a valid api token.'end;local bE=fs.open("luam.key","r").readAll()if not fs.exists(_)then return'"package.json" not found. Run "luam init" to initialize package.'end;local R=decodeFromFile(_)bz(R)local bF=fs.combine(P,".luamignore")local bG={}if fs.exists(bF)then local bH=fs.open(bF,"r")local bI="temp"while bI do bI=bH.readLine()if not bI then break end;table.insert(bG,P.."/"..bI)end end;local bJ=z(P,bG)local bK={name=R.name,version=R.version,dependencies=R.dependencies,payload=bJ}local bC=fs.open(".luamversioncache".."/"..R.name,"w")bC.write(R.version)bC.close()local aP,bL,bM=http.post(by,encode(bK),{Authorization=bE})if not aP then if not bM then return"The request timed out. Either luam is down or it is blocked on your network"end;return string.format("%s: %s",bL,decode(bM.readAll()).message or"No message provided")end;return string.format("%s v%s was posted successfully!",R.name,R.version)end;return bD end,["functions.help"]=function()local function bN(M)print("No help yet! This feature is coming extremely soon though.")end;return bN end,["functions.delete"]=function()require"functions.json"require"functions.delete.deletePackage"local bu=require"functions.delete.deletePackage"local function K(M)local P=shell.dir()local bO=M[2]if not bO then return end;local _=fs.combine(P,"package.json")if not _ then return"No package.json found."end;local R=decodeFromFile(_)if not R.dependencies then return"No dependencies to delete"end;if not R.dependencies[bO]then return string.format("%s not found. Perhaps you made a typo?",bO)end;R.dependencies[bO]=nil;local aL=fs.combine(P,"package-lock.json")local at={}if fs.exists(_)then at=decodeFromFile(aL)end;local bP=P.."/luam_modules/"..bO;if not fs.exists(bP)then return string.format("%s not found",bP)end;bu(bO,bP,at)local T=fs.open(_,"w")T.write(encodePretty(R))T.close()local aU=fs.open(aL,"w")aU.write(encodePretty(at))aU.close()end;return K end,["tar.lib"]=function()local bQ=true;local bR="000755 \0"local bS=string.rep("\0",32)local bT=bS;local bU=string.rep("\0",100)local bV="000000 \0"local bW=bV;local bX=bV;local bY=bW;local bZ="0"local b_="5"local c0="00"local c1="ustar\0"local c2=string.rep(" ",8)local c3=string.rep("\0",512)local function c4(string,c5,i)i=i or"0"if#string>=c5 then return string end;return string.rep(i,c5-#string)..string end;local function c6(string,c5,i)i=i or"0"if#string>=c5 then return string end;return string..string.rep(i,c5-#string)end;local function c7(c8)return string.format("%o",c8)end;local function c9(ca)local cb=0;for i in string.gmatch(ca,".")do cb=cb+string.byte(i)end;return string.format("%06s",c7(cb)).."\0 "end;local function cc(ab,c)local cd=ab.."/"..c;assert(fs.exists(cd),"The file path "..cd.." does not exist")local ce=fs.isDir(cd)and b_ or bZ;local cf=c4(c7(fs.getSize(cd)),11,0).." "local cg=c4(c7(os.date("%s")),11).." "local N,ch;if#c>100 then ch=string.sub(c,1,155)N=c6(string.sub(c,156,255),100,"\0")else N=c6(c,100,"\0")ch=string.rep("\0",155)end;local ci=N..bR..bX..bY..cf..cg;local cj=ce..bU..c1 ..c0 ..bS..bT..bV..bW..ch;local cb=c9(ci..c2 ..cj)return c6(ci..cb..cj,512,"\0")end;local function ck(ca,cl)for h=1,#ca do cl.write(string.byte(ca,h))end end;local function z(ab,c,cl)local cd=ab.."/"..c;assert(fs.exists(cd))local ca=cc(ab,c)ck(ca,cl)local cf=fs.getSize(cd)local w=0;if not fs.isDir(cd)then w=512-cf%512 end;local A=fs.open(cd,"rb")for B=1,cf do cl.write(A.read())end;for B=1,w do cl.write(0)end end;local function cm(cl)for B=1,1024 do cl.write(0)end;cl.close()end;local function ae(cn,af)for B,ag in ipairs(cn)do if ag==af then return true end end;return false end;local function co(ab,cp,cq,F,cr)local cs=ab.."/"..cp;if ae(cq,cs)then return end;if not fs.isDir(cs)then z(ab,cp,F)return else if#fs.list(cs)==0 then z(ab,cp,F)end end;for B,ct in ipairs(fs.list(cs))do if bQ and string.sub(ct,1,1)~="."or not bQ then local cu=cp.."/"..ct;local cv=ab.."/"..cu;if fs.isDir(cv)then co(ab,cu,cq,F,cr)elseif cv~=cr then if not ae(cq,cv)then z(ab,cu,F)end end end end end;local function a7(c,s,cq,F)assert(c,"No path was provided")if s then assert(string.sub(s,-4)==".tar","Output file path must end with .tar!")end;local ab,cw=string.match(c,"(.-)/([^/]+)$")ab=ab or""cw=cw or c;s=s or"/"..ab.."/"..cw..".tar"F=F or fs.open(s,"wb")co(ab,cw,cq,F,s)cm(F)end;local function cx(ca,cy,cz)local cA=ca:sub(cy,cz):gsub("\0","")cA=cA:gsub("^%s+","")cA=cA:gsub("%s+$","")return cA end;local function cB(ca)local N=cx(ca,1,100)local ch=cx(ca,345,500)local cf=tonumber(cx(ca,124,136),8)local type=tonumber(cx(ca,156,157))return N,ch,cf,type end;local function cC(E,cf,A)local F=fs.open(E,"wb")for B=1,cf do F.write(A.read())end;local w=512-cf%512;if w~=512 then for B=1,w do A.read()end end;F.close()end;local function cD(c,E)E=E or shell.dir()assert(fs.exists(c))assert(string.sub(c,-4)==".tar","File is not a tar file")assert(fs.getSize(c)%512==0,"File size is not a multiple of 512. Invalid tar.")local A=fs.open(c,"rb")for B=1,fs.getSize(c)/512-1 do local ca=A.read(512)if ca==nil then return end;if ca~=c3 then local N,ch,cf,type=cB(ca)local cE=E.."/"..(ch and ch..N or N)if type==5 then fs.makeDir(cE)else if not fs.exists(cE)then cC(cE,cf,A)else for h=1,512 do A.read()end end end end end end;local aW={tar=a7,untar=cD}return aW end}if d[c]then return d[c]else return b(c)end end end;local M={...}if M[1]~=".luam"then local a3=require"functions.init"local bD=require"functions.post"local cF=require"functions.add"local a5=require"functions.login"local K=require"functions.delete"local cG=require"functions.versions"local Z=cG.increment_version;local a2=cG.list_version;local bN=require"functions.help"local cH={init=a3,post=bD,add=cF,a=cF,delete=K,d=K,login=a5,help=bN,version=a2,v=a2,patch=function()Z("patch")end,minor=function()Z("minor")end,major=function()Z("major")end}local cy=os.clock()local cI,aP=pcall(function()if not M[1]then error("At least one argument expected.")end;if not cH[M[1]]then error(string.format("%s is not a valid command",M[1]))end;local aP=cH[M[1]](M)return aP end)if not cI then print("Error!")end;if aP then print(aP)end;print(string.format("Finished in %0.3f seconds",os.clock()-cy))else local function cJ(b4,cK)local aP={}for cL in(b4 ..cK):gmatch("(.-)"..cK)do table.insert(aP,cL)end;return aP end;local cM=require;local function cN(cO,cP)while#cO>0 do local c=table.concat(cO,"/").."/luam_modules/"..cP;local cQ,cR=pcall(cM,c:gsub("/","."))if cQ then return cR end;table.remove(cO)table.remove(cO)end end;function require(cP)local cS=debug.getinfo(2,"S")local c=cS.source:sub(2)c=c:match("(.*/)")or""c=c:sub(1,#c-1)local cO=cJ(c,"/")local cR=cN(cO,cP)if cR then return cR end;return cM(cP)end end
