do local a=package.searchers or package.loaders;local b=a[2]a[2]=function(c)local d={["base64.lib"]=function()local e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"local f={}local g={}for h=1,#e do local i=e:sub(h,h)f[h]=i;g[i]=h-1 end;local j,k,l=bit.blshift,bit.blogic_rshift,bit.band;local function m(n,o,p)assert(n,"At least one input byte required")local q=not o and 1 or not p and 2 or 3;o=o or 0;p=p or 0;local r=j(n,16)+j(o,8)+p;local s=""for h=3,3-q,-1 do s=s..f[1+tonumber(l(k(r,h*6),0x3f))]end;s=s..string.rep("=",3-q)return s end;local function u(v)assert(#v==4,"Chars must be of length 4")local w=#v:gsub("[^=]","")local x=v:gsub("=","A")local y=0;local s={}for h=1,4 do y=y+j(g[x:sub(h,h)],24-h*6)end;for h=1,3 do s[h]=l(k(y,24-h*8),0xff)end;return s,w end;local function z(c)assert(fs.exists(c),'File does not exist')local A=fs.open(c,"rb")local s=""for B=1,fs.getSize(c),3 do local n,o,p=A.read(),A.read(),A.read()s=s..m(n,o,p)end;return s end;local function C(D,E)assert(#D%4==0,"Coded string should be a multiple of 4")local F=fs.open(E,"wb")for h=1,#D,4 do local G,w=u(D:sub(h,h+3))for H=1,3-w do F.write(G[H])end end;F.close()end;local I={encodeFile=z,decodeFile=C}return I end,["functions.versions"]=function()require"functions.json"local function J(K,L)local M,N,O=K:match("(%d+)%.(%d+)%.(%d+)")M,N,O=tonumber(M),tonumber(N),tonumber(O)if L=="major"then return string.format("%d.0.0",M+1)elseif L=="minor"then return string.format("%d.%d.0",M,N+1)elseif L=="patch"then return string.format("%d.%d.%d",M,N,O+1)else error("Invalid increment type: "..L)end end;local function P(L)local Q=shell.dir()local R=fs.combine(Q,"package.json")if not fs.exists(R)then return"No package.json found!"end;local S=decodeFromFile(R)if not S["version"]then return"Must initialize package before incrementing version. Run luam init"end;local T=J(S["version"],L or"patch")print(string.format("Updated to %s",T))S["version"]=T;local U=fs.open(R,"w")U.write(encodePretty(S))U.close()return T end;local function V()local Q=shell.dir()local R=fs.combine(Q,"package.json")if not fs.exists(R)then return"No package.json found!"end;local S=decodeFromFile(R)if not S["version"]then return"Must initialize package before incrementing version. Run luam init"end;print(string.format("Current package version: %s",S.version))end;return{list_version=V,increment_version=P}end,["functions.init"]=function()require"functions.json"local function W(X)local Q=shell.dir()if X[2]then Q=Q.."/"..X[2]end;local R=fs.combine(Q,"package.json")local S={}if fs.exists(R)then S=decodeFromFile(R)end;if S["name"]then print("Package has already been initialized")end;local Y=X[2]or Q:match("([^/]+)$")local F=fs.open(R,"w")S["name"]=Y;S["version"]="0.1.0"S["dependencies"]=S["dependencies"]or{}F.write(encodePretty(S))local Z=fs.open(fs.combine(Q,".luamignore"),"w")Z.write("luam_modules\n")Z.write("package-lock.json")return string.format("Package %s has been initialized",Y)end;return W end,["functions.login"]=function()local function _(X)local a0=fs.open("luam.key","w")a0.write(X[2])a0.close()return"API token now in use"end;return _ end,["functions.install"]=function()local a1=require"functions.install.downloadFile"local a2=require"functions.delete"require"functions.json"local function a3(X)local Y=X[2]local K=X[3]if not Y then return"A name must be provided in order to add a package"end;local Q=shell.dir()local a4=fs.combine(Q,"package.json")local S={}if fs.exists(a4)then S=decodeFromFile(a4)end;if S and S.dependencies and S.dependencies[Y]then a2({0,Y})end;local a5=a1(Y,K)if not S.dependencies then S.dependencies={}end;S.dependencies[X[2]]="^"..a5;local a6=fs.open(a4,"w")a6.write(encodePretty(S))end;return a3 end,["functions.install.downloadFile"]=function()require"functions.json"local a7=require("tar.lib")local a8=require("base64.lib")local a9="https://api.luam.dev/packages/install"local function aa(ab,Y,ac)local ad=ab.."/"..Y..".tar"a8.decodeFile(ac,ad)a7.untar(ad,ab)fs.delete(ad)end;local function ae(table,af)for B,ag in ipairs(table)do if ag==af then return true end end;return false end;local function ah(ai)local aj={}for B,af in ipairs(ai)do table.insert(aj,af)end;return aj end;local function ak(al,am,h,Y)for H=1,h do al=al.."/luam_modules/"..am[H]end;if Y then al=al.."/luam_modules/"..Y end;return al end;local function an(ao)local ap=ao:match(".*()/")return ap and ao:sub(1,ap-1)or ao end;local function aq(c,ar,as,at)c=c.."/luam_modules/"..ar;while#c>0 do local x=at[c]if x and x.name==ar and x.version==as then return c end;for h=1,3 do local au=c;c=an(c)if au==c then return false end end;c=c.."/"..ar end end;local function av(aw,ax,at)local ay=""for c,x in pairs(at)do if x.name==aw.name and x.version==aw.version then ay=c end end;fs.copy(ay,ax)return ay end;local function a3(al,az,at,aA,aB)local aC={}local aD=az[aA][aB]aD.name=aA;aD.version=aB;aD.options={}table.insert(aC,aD)for B,af in ipairs(aC)do local Y=af.name;local K=af.version;local am=af.options;local aE=ah(am)table.insert(aE,Y)for h=0,#am do local ax=ak(al,am,h,Y)if at[ax]and at[ax].version==K then break end;if not at[ax]then if af.payload then aa(an(ax),Y,af.payload)at[ax]={name=af.name,version=af.version,dependencies=af.dependencies}for aF,aG in pairs(af.providedDependencyVersions)do local aH=nil;if az[aF]and az[aF][aG]then aH=az[aF][aG]aH.name=aF;aH.version=aG else aH={name=aF,version=aG}end;aH.options=aE;table.insert(aC,aH)end else local aI=""if K then aI=av(af,ax,at)else local aJ=aq(af.copied_from_path,Y)aI=av(aJ,ax,at)end;local aK=at[aI]at[ax]=aK;for aF,B in pairs(aK.dependencies)do table.insert(aC,{options=aE,name=aF,copied_from_path=aI})end end;break end end end end;local function a1(Y,K)local Q=shell.dir()local aL=fs.combine(Q,"package-lock.json")local at={}if fs.exists(aL)then at=decodeFromFile(aL)or{}end;local aM={}for B,package in pairs(at)do local Y=package.name;local K=package.version;if not aM[Y]then aM[Y]={}end;if not ae(aM[Y],K)then table.insert(aM[Y],K)end end;local aN=encode(aM)if aN=="[]"then aN="{}"end;local aO={["X-PackageName"]=Y,["X-PackageVersion"]=K,["Content-Type"]="application/json"}local aP,aQ,aR=http.post(a9,aN,aO)if not aP then error(string.format("%s: %s",aQ,aR and aR.readAll()))end;local aS=decode(aP.readAll())local a5=K;for aT in pairs(aS[Y])do a5=aT end;a3(Q,aS,at,Y,a5)local aU=fs.open(aL,"w")aU.write(encodePretty(at))aU.close()local aV=0;for K,B in pairs(aS)do for package,B in pairs(aS[K])do aV=aV+1 end end;print(string.format("%s package%s installed",aV,aV>1 and"s"or""))return a5 end;return a1 end,["functions.post.encodeFile"]=function()local aW=require("tar.lib")local I=require("base64.lib")local function z(c,aX)assert(fs.exists(c),"File does not exist!")local aY="temp-"..math.floor(1000*math.random())..".tar"aW.tar(c,aY,aX)local aZ=I.encodeFile(aY)fs.delete(aY)return aZ end;return z end,["functions.json"]=function()local a_={["\n"]="\\n",["\r"]="\\r",["\t"]="\\t",["\b"]="\\b",["\f"]="\\f",["\""]="\\\"",["\\"]="\\\\"}local function b0(t)local b1=0;for aT,b2 in pairs(t)do if type(aT)~="number"then return false elseif aT>b1 then b1=aT end end;return b1==#t end;local b3={['\n']=true,['\r']=true,['\t']=true,[' ']=true,[',']=true,[':']=true}function removeWhite(b4)while b3[b4:sub(1,1)]do b4=b4:sub(2)end;return b4 end;local function b5(b6,b7,b8,b9)local b4=""local function ba(bb)b4=b4 ..("\t"):rep(b8)..bb end;local function bc(b6,bd,be,bf,bg)b4=b4 ..bd;if b7 then b4=b4 .."\n"b8=b8+1 end;for aT,b2 in bf(b6)do ba("")bg(aT,b2)b4=b4 ..","if b7 then b4=b4 .."\n"end end;if b7 then b8=b8-1 end;if b4:sub(-2)==",\n"then b4=b4:sub(1,-3).."\n"elseif b4:sub(-1)==","then b4=b4:sub(1,-2)end;ba(be)end;if type(b6)=="table"then b9[b6]=true;if b0(b6)then bc(b6,"[","]",ipairs,function(aT,b2)b4=b4 ..b5(b2,b7,b8,b9)end)else bc(b6,"{","}",pairs,function(aT,b2)assert(type(aT)=="string","JSON object keys must be strings",2)b4=b4 ..b5(aT,b7,b8,b9)b4=b4 ..(b7 and": "or":")..b5(b2,b7,b8,b9)end)end elseif type(b6)=="string"then b4='"'..b6:gsub("[%c\"\\]",a_)..'"'elseif type(b6)=="number"or type(b6)=="boolean"then b4=tostring(b6)else error("JSON only supports arrays, objects, numbers, booleans, and strings",2)end;return b4 end;function encode(b6)return b5(b6,false,0,{})end;function encodePretty(b6)return b5(b6,true,0,{})end;local bh={}for aT,b2 in pairs(a_)do bh[b2]=aT end;function parseBoolean(b4)if b4:sub(1,4)=="true"then return true,removeWhite(b4:sub(5))else return false,removeWhite(b4:sub(6))end end;function parseNull(b4)return nil,removeWhite(b4:sub(5))end;local bi={['e']=true,['E']=true,['+']=true,['-']=true,['.']=true}function parseNumber(b4)local h=1;while bi[b4:sub(h,h)]or tonumber(b4:sub(h,h))do h=h+1 end;local b6=tonumber(b4:sub(1,h-1))b4=removeWhite(b4:sub(h))return b6,b4 end;function parseString(b4)b4=b4:sub(2)local bb=""while b4:sub(1,1)~="\""do local bj=b4:sub(1,1)b4=b4:sub(2)assert(bj~="\n","Unclosed string")if bj=="\\"then local bk=b4:sub(1,1)b4=b4:sub(2)bj=assert(bh[bj..bk],"Invalid escape character")end;bb=bb..bj end;return bb,removeWhite(b4:sub(2))end;function parseArray(b4)b4=removeWhite(b4:sub(2))local b6={}local h=1;while b4:sub(1,1)~="]"do local b2=nil;b2,b4=parseValue(b4)b6[h]=b2;h=h+1;b4=removeWhite(b4)end;b4=removeWhite(b4:sub(2))return b6,b4 end;function parseObject(b4)b4=removeWhite(b4:sub(2))local b6={}while b4:sub(1,1)~="}"do local aT,b2=nil,nil;aT,b2,b4=parseMember(b4)b6[aT]=b2;b4=removeWhite(b4)end;b4=removeWhite(b4:sub(2))return b6,b4 end;function parseMember(b4)local aT=nil;aT,b4=parseValue(b4)local b6=nil;b6,b4=parseValue(b4)return aT,b6,b4 end;function parseValue(b4)local bl=b4:sub(1,1)if bl=="{"then return parseObject(b4)elseif bl=="["then return parseArray(b4)elseif tonumber(bl)~=nil or bi[bl]then return parseNumber(b4)elseif b4:sub(1,4)=="true"or b4:sub(1,5)=="false"then return parseBoolean(b4)elseif bl=="\""then return parseString(b4)elseif b4:sub(1,4)=="null"then return parseNull(b4)end;return nil end;function decode(b4)b4=removeWhite(b4)t=parseValue(b4)return t end;function decodeFromFile(c)local bm=assert(fs.open(c,"r"))local bn=decode(bm.readAll())bm.close()return bn end end,["functions.delete.deletePackage"]=function()local function an(ao)local ap=ao:match(".*()/")return ap and ao:sub(1,ap-1)or ao end;local function bo(bp,bq,br,at)br=br.."/luam_modules/"..bp;while br~=bq do if at[br]then return false end;for B=1,3 do br=an(br)end;br=br.."/"..bp end;return true end;local function aq(c,ar,at)c=c.."/luam_modules/"..ar;while#c>0 do local x=at[c]if x then return c end;for h=1,3 do local au=c;c=an(c)if au==c then return end end;c=c.."/"..ar end end;local function bs(ai,bt)for aT,B in pairs(ai)do if aT==bt then return true end end;return false end;local function bu(Y,c,at)for a4,aw in pairs(at)do if bs(aw.dependencies,Y)then print(aw.name)if bo(Y,c,a4,at)then return end end end;local x=at[c]local bv=x.dependencies;fs.delete(c)at[c]=nil;for bw in pairs(at)do if bw:sub(1,#c)==c then at[bw]=nil end end;for aF in pairs(bv)do local bx=aq(c,aF,at)if bx then bu(aF,bx,at)end end end;return bu end,["functions.post"]=function()local z=require("functions.post.encodeFile")local P=require("functions.versions")require("functions.json")local by="https://api.luam.dev/packages"local function bz(S)local bA={"name","version","dependencies"}for B,bB in ipairs(bA)do if not S[bB]then error(string.format('Required field "%s" missing from package.json',bB))end end;local bC=fs.open(string.format(".luamversioncache/%s",S.name),"r")if bC then local K=bC.readAll()if K==S["version"]then local T=P("patch")S["version"]=T end end end;local function bD()local Q=shell.dir()local R=fs.combine(Q,"package.json")if not fs.exists('luam.key')then return'No api token found. Run luam login and provide a valid api token.'end;local bE=fs.open("luam.key","r").readAll()if not fs.exists(R)then return'"package.json" not found. Run "luam init" to initialize package.'end;local S=decodeFromFile(R)bz(S)local bF=fs.combine(Q,".luamignore")local bG={}if fs.exists(bF)then local bH=fs.open(bF,"r")local bI="temp"while bI do bI=bH.readLine()if not bI then break end;table.insert(bG,Q.."/"..bI)end end;local bJ=z(Q,bG)local bK={name=S.name,version=S.version,dependencies=S.dependencies,payload=bJ}local bC=fs.open(".luamversioncache".."/"..S.name,"w")bC.write(S.version)bC.close()local aP,bL,bM=http.post(by,encode(bK),{Authorization=bE})if not aP then if not bM then return"The request timed out. Either luam is down or it is blocked on your network"end;return string.format("%s: %s",bL,decode(bM.readAll()).message or"No message provided")end;return string.format("%s v%s was posted successfully!",S.name,S.version)end;return bD end,["functions.list"]=function()local function bN(table)for B,B in pairs(table)do return true end;return false end;local function bO(table)local aP=0;for B,B in pairs(table)do aP=aP+1 end;return aP end;local function bP()local Q=shell.dir()local R=fs.combine(Q,"package.json")local aL=fs.combine(Q,"package-lock.json")if not fs.exists(R)then return"No package.json found!"end;if not fs.exists(aL)then return"No packages installed"end;local S=decodeFromFile(R)local at=decodeFromFile(aL)if not at then return"Must have package lock to run list command"end;if not bN(at)then return"No packages installed"end;local bQ=bO(S.dependencies)print()print(string.format("%s dependenc%s",bQ,bQ>1 and"ies"or"y"))print()for bR,K in pairs(S.dependencies)do print(bR.." "..K)end;print()print(string.format("%s packages installed",bO(at)))print("")for c,x in pairs(at)do c=c:gsub(Q,""):gsub("/luam_modules/","")c=c:gsub("/"," > ")print(string.format("%s %s",c,x.version))end;print()end;return bP end,["functions.help"]=function()local function bS(X)print("No help yet! This feature is coming extremely soon though.")end;return bS end,["functions.delete"]=function()require"functions.json"require"functions.delete.deletePackage"local bu=require"functions.delete.deletePackage"local function a2(X)local Q=shell.dir()local bT=X[2]if not bT then return end;local R=fs.combine(Q,"package.json")if not R then return"No package.json found."end;local S=decodeFromFile(R)if not S.dependencies then return"No dependencies to delete"end;if not S.dependencies[bT]then return string.format("%s not found. Perhaps you made a typo?",bT)end;S.dependencies[bT]=nil;local aL=fs.combine(Q,"package-lock.json")local at={}if fs.exists(R)then at=decodeFromFile(aL)end;local bU=Q.."/luam_modules/"..bT;if not fs.exists(bU)then return string.format("%s not found",bU)end;bu(bT,bU,at)local a6=fs.open(R,"w")a6.write(encodePretty(S))a6.close()local aU=fs.open(aL,"w")aU.write(encodePretty(at))aU.close()end;return a2 end,["tar.lib"]=function()local bV=true;local bW="000755 \0"local bX=string.rep("\0",32)local bY=bX;local bZ=string.rep("\0",100)local b_="000000 \0"local c0=b_;local c1=b_;local c2=c0;local c3="0"local c4="5"local c5="00"local c6="ustar\0"local c7=string.rep(" ",8)local c8=string.rep("\0",512)local function c9(string,ca,i)i=i or"0"if#string>=ca then return string end;return string.rep(i,ca-#string)..string end;local function cb(string,ca,i)i=i or"0"if#string>=ca then return string end;return string..string.rep(i,ca-#string)end;local function cc(cd)return string.format("%o",cd)end;local function ce(cf)local cg=0;for i in string.gmatch(cf,".")do cg=cg+string.byte(i)end;return string.format("%06s",cc(cg)).."\0 "end;local function ch(ab,c)local ci=ab.."/"..c;assert(fs.exists(ci),"The file path "..ci.." does not exist")local cj=fs.isDir(ci)and c4 or c3;local ck=c9(cc(fs.getSize(ci)),11,0).." "local cl=c9(cc(os.date("%s")),11).." "local Y,cm;if#c>100 then cm=string.sub(c,1,155)Y=cb(string.sub(c,156,255),100,"\0")else Y=cb(c,100,"\0")cm=string.rep("\0",155)end;local cn=Y..bW..c1 ..c2 ..ck..cl;local co=cj..bZ..c6 ..c5 ..bX..bY..b_..c0 ..cm;local cg=ce(cn..c7 ..co)return cb(cn..cg..co,512,"\0")end;local function cp(cf,cq)for h=1,#cf do cq.write(string.byte(cf,h))end end;local function z(ab,c,cq)local ci=ab.."/"..c;assert(fs.exists(ci))local cf=ch(ab,c)cp(cf,cq)local ck=fs.getSize(ci)local w=0;if not fs.isDir(ci)then w=512-ck%512 end;local A=fs.open(ci,"rb")for B=1,ck do cq.write(A.read())end;for B=1,w do cq.write(0)end end;local function cr(cq)for B=1,1024 do cq.write(0)end;cq.close()end;local function ae(cs,af)for B,ag in ipairs(cs)do if ag==af then return true end end;return false end;local function ct(ab,cu,cv,F,cw)local cx=ab.."/"..cu;if ae(cv,cx)then return end;if not fs.isDir(cx)then z(ab,cu,F)return else if#fs.list(cx)==0 then z(ab,cu,F)end end;for B,cy in ipairs(fs.list(cx))do if bV and string.sub(cy,1,1)~="."or not bV then local cz=cu.."/"..cy;local cA=ab.."/"..cz;if fs.isDir(cA)then ct(ab,cz,cv,F,cw)elseif cA~=cw then if not ae(cv,cA)then z(ab,cz,F)end end end end end;local function a7(c,s,cv,F)assert(c,"No path was provided")if s then assert(string.sub(s,-4)==".tar","Output file path must end with .tar!")end;local ab,cB=string.match(c,"(.-)/([^/]+)$")ab=ab or""cB=cB or c;s=s or"/"..ab.."/"..cB..".tar"F=F or fs.open(s,"wb")ct(ab,cB,cv,F,s)cr(F)end;local function cC(cf,cD,cE)local cF=cf:sub(cD,cE):gsub("\0","")cF=cF:gsub("^%s+","")cF=cF:gsub("%s+$","")return cF end;local function cG(cf)local Y=cC(cf,1,100)local cm=cC(cf,345,500)local ck=tonumber(cC(cf,124,136),8)local type=tonumber(cC(cf,156,157))return Y,cm,ck,type end;local function cH(E,ck,A)local F=fs.open(E,"wb")for B=1,ck do F.write(A.read())end;local w=512-ck%512;if w~=512 then for B=1,w do A.read()end end;F.close()end;local function cI(c,E)E=E or shell.dir()assert(fs.exists(c))assert(string.sub(c,-4)==".tar","File is not a tar file")assert(fs.getSize(c)%512==0,"File size is not a multiple of 512. Invalid tar.")local A=fs.open(c,"rb")for B=1,fs.getSize(c)/512-1 do local cf=A.read(512)if cf==nil then return end;if cf~=c8 then local Y,cm,ck,type=cG(cf)local cJ=E.."/"..(cm and cm..Y or Y)if type==5 then fs.makeDir(cJ)else if not fs.exists(cJ)then cH(cJ,ck,A)else for h=1,512 do A.read()end end end end end end;local aW={tar=a7,untar=cI}return aW end}if d[c]then return d[c]else return b(c)end end end;local X={...}if X[1]~=".luam"then local W=require"functions.init"local bD=require"functions.post"local a3=require"functions.install"local _=require"functions.login"local a2=require"functions.delete"local cK=require"functions.versions"local P=cK.increment_version;local V=cK.list_version;local bS=require"functions.help"local bP=require"functions.list"local cL={init=W,post=bD,install=a3,i=a3,remove=a2,rm=a2,login=_,help=bS,list=bP,ls=bP,version=V,v=V,patch=function()P("patch")end,minor=function()P("minor")end,major=function()P("major")end}local cD=os.clock()local cM,aP=pcall(function()if not X[1]then error("At least one argument expected.")end;if not cL[X[1]]then error(string.format("%s is not a valid command",X[1]))end;local aP=cL[X[1]](X)return aP end)if not cM then print("Error!")end;if aP then print(aP)end;print(string.format("Finished in %0.3f seconds",os.clock()-cD))else local function cN(b4,cO)local aP={}for cP in(b4 ..cO):gmatch("(.-)"..cO)do table.insert(aP,cP)end;return aP end;local cQ=require;local function cR(cS,cT)while#cS>0 do local c=table.concat(cS,"/").."/luam_modules/"..cT;local cU,cV=pcall(cQ,c:gsub("/","."))if cU then return cV end;table.remove(cS)table.remove(cS)end end;function require(cT)local cW=debug.getinfo(2,"S")local c=cW.source:sub(2)c=c:match("(.*/)")or""c=c:sub(1,#c-1)local cS=cN(c,"/")local cV=cR(cS,cT)if cV then return cV end;return cQ(cT)end end
